//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** This is the position and other data related to nodes in the activity graph that you can click to launch activities. An Activity Graph node will only have one active Activity at a time, which will determine the activity to be launched (and, unless overrideDisplay information is provided, will also determine the tooltip and other UI related to the node) */
public struct DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition: APIModel {

    /** The node may have various possible activities that could be active for it, however only one may be active at a time. See the DestinyActivityGraphNodeActivityDefinition for details. */
    public var activities: [DestinyDefinitionsDirectorDestinyActivityGraphNodeActivityDefinition]?

    /** The node may have various visual accents placed on it, or styles applied. These are the list of possible styles that the Node can have. The game iterates through each, looking for the first one that passes a check of the required game/character/account state in order to show that style, and then renders the node in that style. */
    public var featuringStates: [DestinyDefinitionsDirectorDestinyActivityGraphNodeFeaturingStateDefinition]?

    /** An identifier for the Activity Graph Node, only guaranteed to be unique within its parent Activity Graph. */
    public var nodeId: Int?

    /** The node *may* have display properties that override the active Activity's display properties. */
    public var overrideDisplay: [String: Any]?

    /** The position on the map for this node. */
    public var position: [String: Any]?

    /** Represents possible states that the graph node can be in. These are combined with some checking that happens in the game client and server to determine which state is actually active at any given time. */
    public var states: [DestinyDefinitionsDirectorDestinyActivityGraphNodeStateEntry]?

    public init(activities: [DestinyDefinitionsDirectorDestinyActivityGraphNodeActivityDefinition]? = nil, featuringStates: [DestinyDefinitionsDirectorDestinyActivityGraphNodeFeaturingStateDefinition]? = nil, nodeId: Int? = nil, overrideDisplay: [String: Any]? = nil, position: [String: Any]? = nil, states: [DestinyDefinitionsDirectorDestinyActivityGraphNodeStateEntry]? = nil) {
        self.activities = activities
        self.featuringStates = featuringStates
        self.nodeId = nodeId
        self.overrideDisplay = overrideDisplay
        self.position = position
        self.states = states
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        activities = try container.decodeArrayIfPresent("activities")
        featuringStates = try container.decodeArrayIfPresent("featuringStates")
        nodeId = try container.decodeIfPresent("nodeId")
        overrideDisplay = try container.decodeAnyIfPresent("overrideDisplay")
        position = try container.decodeAnyIfPresent("position")
        states = try container.decodeArrayIfPresent("states")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(activities, forKey: "activities")
        try container.encodeIfPresent(featuringStates, forKey: "featuringStates")
        try container.encodeIfPresent(nodeId, forKey: "nodeId")
        try container.encodeAnyIfPresent(overrideDisplay, forKey: "overrideDisplay")
        try container.encodeAnyIfPresent(position, forKey: "position")
        try container.encodeIfPresent(states, forKey: "states")
    }

    public static func == (lhs: DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition, rhs: DestinyDefinitionsDirectorDestinyActivityGraphNodeDefinition) -> Bool {
        guard lhs.activities == rhs.activities else { return false }
        guard lhs.featuringStates == rhs.featuringStates else { return false }
        guard lhs.nodeId == rhs.nodeId else { return false }
        guard NSDictionary(dictionary: lhs.overrideDisplay ?? [:]).isEqual(to: rhs.overrideDisplay ?? [:]) else { return false }
        guard NSDictionary(dictionary: lhs.position ?? [:]).isEqual(to: rhs.position ?? [:]) else { return false }
        guard lhs.states == rhs.states else { return false }
        return true
    }
}
