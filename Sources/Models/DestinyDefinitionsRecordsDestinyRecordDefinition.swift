//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public struct DestinyDefinitionsRecordsDestinyRecordDefinition: APIModel {

    public var completionInfo: DestinyDefinitionsRecordsDestinyRecordCompletionBlock?

    public var displayProperties: DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition?

    public var expirationInfo: DestinyDefinitionsRecordsDestinyRecordExpirationBlock?

    /** The unique identifier for this entity. Guaranteed to be unique for the type of entity, but not globally.
When entities refer to each other in Destiny content, it is this hash that they are referring to. */
    public var hash: Int?

    /** The index of the entity as it was found in the investment tables. */
    public var index: Int?

    /** Some records have multiple 'interval' objectives, and the record may be claimed at each completed interval */
    public var intervalInfo: [String: Any]?

    public var loreHash: Int?

    public var objectiveHashes: [Int]?

    public var presentationInfo: DestinyDefinitionsPresentationDestinyPresentationChildBlock?

    public var recordValueStyle: Int?

    /** If this is true, then there is an entity with this identifier/type combination, but BNet is not yet allowed to show it. Sorry! */
    public var redacted: Bool?

    public var requirements: DestinyDefinitionsPresentationDestinyPresentationNodeRequirementsBlock?

    /** If there is any publicly available information about rewards earned for achieving this record, this is the list of those items.
 However, note that some records intentionally have "hidden" rewards. These will not be returned in this list. */
    public var rewardItems: [DestinyDestinyItemQuantity]?

    /** Indicates whether this Record's state is determined on a per-character or on an account-wide basis. */
    public var scope: Int?

    public var stateInfo: DestinyDefinitionsRecordsSchemaRecordStateBlock?

    public var titleInfo: DestinyDefinitionsRecordsDestinyRecordTitleBlock?

    public init(completionInfo: DestinyDefinitionsRecordsDestinyRecordCompletionBlock? = nil, displayProperties: DestinyDefinitionsCommonDestinyDisplayPropertiesDefinition? = nil, expirationInfo: DestinyDefinitionsRecordsDestinyRecordExpirationBlock? = nil, hash: Int? = nil, index: Int? = nil, intervalInfo: [String: Any]? = nil, loreHash: Int? = nil, objectiveHashes: [Int]? = nil, presentationInfo: DestinyDefinitionsPresentationDestinyPresentationChildBlock? = nil, recordValueStyle: Int? = nil, redacted: Bool? = nil, requirements: DestinyDefinitionsPresentationDestinyPresentationNodeRequirementsBlock? = nil, rewardItems: [DestinyDestinyItemQuantity]? = nil, scope: Int? = nil, stateInfo: DestinyDefinitionsRecordsSchemaRecordStateBlock? = nil, titleInfo: DestinyDefinitionsRecordsDestinyRecordTitleBlock? = nil) {
        self.completionInfo = completionInfo
        self.displayProperties = displayProperties
        self.expirationInfo = expirationInfo
        self.hash = hash
        self.index = index
        self.intervalInfo = intervalInfo
        self.loreHash = loreHash
        self.objectiveHashes = objectiveHashes
        self.presentationInfo = presentationInfo
        self.recordValueStyle = recordValueStyle
        self.redacted = redacted
        self.requirements = requirements
        self.rewardItems = rewardItems
        self.scope = scope
        self.stateInfo = stateInfo
        self.titleInfo = titleInfo
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        completionInfo = try container.decodeIfPresent("completionInfo")
        displayProperties = try container.decodeIfPresent("displayProperties")
        expirationInfo = try container.decodeIfPresent("expirationInfo")
        hash = try container.decodeIfPresent("hash")
        index = try container.decodeIfPresent("index")
        intervalInfo = try container.decodeAnyIfPresent("intervalInfo")
        loreHash = try container.decodeIfPresent("loreHash")
        objectiveHashes = try container.decodeArrayIfPresent("objectiveHashes")
        presentationInfo = try container.decodeIfPresent("presentationInfo")
        recordValueStyle = try container.decodeIfPresent("recordValueStyle")
        redacted = try container.decodeIfPresent("redacted")
        requirements = try container.decodeIfPresent("requirements")
        rewardItems = try container.decodeArrayIfPresent("rewardItems")
        scope = try container.decodeIfPresent("scope")
        stateInfo = try container.decodeIfPresent("stateInfo")
        titleInfo = try container.decodeIfPresent("titleInfo")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(completionInfo, forKey: "completionInfo")
        try container.encodeIfPresent(displayProperties, forKey: "displayProperties")
        try container.encodeIfPresent(expirationInfo, forKey: "expirationInfo")
        try container.encodeIfPresent(hash, forKey: "hash")
        try container.encodeIfPresent(index, forKey: "index")
        try container.encodeAnyIfPresent(intervalInfo, forKey: "intervalInfo")
        try container.encodeIfPresent(loreHash, forKey: "loreHash")
        try container.encodeIfPresent(objectiveHashes, forKey: "objectiveHashes")
        try container.encodeIfPresent(presentationInfo, forKey: "presentationInfo")
        try container.encodeIfPresent(recordValueStyle, forKey: "recordValueStyle")
        try container.encodeIfPresent(redacted, forKey: "redacted")
        try container.encodeIfPresent(requirements, forKey: "requirements")
        try container.encodeIfPresent(rewardItems, forKey: "rewardItems")
        try container.encodeIfPresent(scope, forKey: "scope")
        try container.encodeIfPresent(stateInfo, forKey: "stateInfo")
        try container.encodeIfPresent(titleInfo, forKey: "titleInfo")
    }

    public static func == (lhs: DestinyDefinitionsRecordsDestinyRecordDefinition, rhs: DestinyDefinitionsRecordsDestinyRecordDefinition) -> Bool {
        guard lhs.completionInfo == rhs.completionInfo else { return false }
        guard lhs.displayProperties == rhs.displayProperties else { return false }
        guard lhs.expirationInfo == rhs.expirationInfo else { return false }
        guard lhs.hash == rhs.hash else { return false }
        guard lhs.index == rhs.index else { return false }
        guard NSDictionary(dictionary: lhs.intervalInfo ?? [:]).isEqual(to: rhs.intervalInfo ?? [:]) else { return false }
        guard lhs.loreHash == rhs.loreHash else { return false }
        guard lhs.objectiveHashes == rhs.objectiveHashes else { return false }
        guard lhs.presentationInfo == rhs.presentationInfo else { return false }
        guard lhs.recordValueStyle == rhs.recordValueStyle else { return false }
        guard lhs.redacted == rhs.redacted else { return false }
        guard lhs.requirements == rhs.requirements else { return false }
        guard lhs.rewardItems == rhs.rewardItems else { return false }
        guard lhs.scope == rhs.scope else { return false }
        guard lhs.stateInfo == rhs.stateInfo else { return false }
        guard lhs.titleInfo == rhs.titleInfo else { return false }
        return true
    }
}
