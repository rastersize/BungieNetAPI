//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** An item can have objectives on it. In practice, these are the exclusive purview of "Quest Step" items: DestinyInventoryItemDefinitions that represent a specific step in a Quest.
Quest steps have 1:M objectives that we end up processing and returning in live data as DestinyQuestStatus data, and other useful information. */
public struct DestinyDefinitionsDestinyItemObjectiveBlockDefinition: APIModel {

    /** For every entry in objectiveHashes, there is a corresponding entry in this array at the same index. If the objective is meant to be associated with a specific DestinyActivityDefinition, there will be a valid hash at that index. Otherwise, it will be invalid (0).
Rendered somewhat obsolete by perObjectiveDisplayProperties, which currently has much the same information but may end up with more info in the future. */
    public var displayActivityHashes: [Int]?

    /** The localized string for narrative text related to this quest step, if any. */
    public var narrative: String?

    /** The hashes to Objectives (DestinyObjectiveDefinition) that are part of this Quest Step, in the order that they should be rendered. */
    public var objectiveHashes: [Int]?

    /** The localized string describing an action to be performed associated with the objectives, if any. */
    public var objectiveVerbName: String?

    /** One entry per Objective on the item, it will have related display information. */
    public var perObjectiveDisplayProperties: [DestinyDefinitionsDestinyObjectiveDisplayProperties]?

    /** A hashed value for the questTypeIdentifier, because apparently I like to be redundant. */
    public var questTypeHash: Int?

    /** The identifier for the type of quest being performed, if any. Not associated with any fixed definition, yet. */
    public var questTypeIdentifier: String?

    /** The hash for the DestinyInventoryItemDefinition representing the Quest to which this Quest Step belongs. */
    public var questlineItemHash: Int?

    /** If True, all objectives must be completed for the step to be completed. If False, any one objective can be completed for the step to be completed. */
    public var requireFullObjectiveCompletion: Bool?

    public init(displayActivityHashes: [Int]? = nil, narrative: String? = nil, objectiveHashes: [Int]? = nil, objectiveVerbName: String? = nil, perObjectiveDisplayProperties: [DestinyDefinitionsDestinyObjectiveDisplayProperties]? = nil, questTypeHash: Int? = nil, questTypeIdentifier: String? = nil, questlineItemHash: Int? = nil, requireFullObjectiveCompletion: Bool? = nil) {
        self.displayActivityHashes = displayActivityHashes
        self.narrative = narrative
        self.objectiveHashes = objectiveHashes
        self.objectiveVerbName = objectiveVerbName
        self.perObjectiveDisplayProperties = perObjectiveDisplayProperties
        self.questTypeHash = questTypeHash
        self.questTypeIdentifier = questTypeIdentifier
        self.questlineItemHash = questlineItemHash
        self.requireFullObjectiveCompletion = requireFullObjectiveCompletion
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        displayActivityHashes = try container.decodeArrayIfPresent("displayActivityHashes")
        narrative = try container.decodeIfPresent("narrative")
        objectiveHashes = try container.decodeArrayIfPresent("objectiveHashes")
        objectiveVerbName = try container.decodeIfPresent("objectiveVerbName")
        perObjectiveDisplayProperties = try container.decodeArrayIfPresent("perObjectiveDisplayProperties")
        questTypeHash = try container.decodeIfPresent("questTypeHash")
        questTypeIdentifier = try container.decodeIfPresent("questTypeIdentifier")
        questlineItemHash = try container.decodeIfPresent("questlineItemHash")
        requireFullObjectiveCompletion = try container.decodeIfPresent("requireFullObjectiveCompletion")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(displayActivityHashes, forKey: "displayActivityHashes")
        try container.encodeIfPresent(narrative, forKey: "narrative")
        try container.encodeIfPresent(objectiveHashes, forKey: "objectiveHashes")
        try container.encodeIfPresent(objectiveVerbName, forKey: "objectiveVerbName")
        try container.encodeIfPresent(perObjectiveDisplayProperties, forKey: "perObjectiveDisplayProperties")
        try container.encodeIfPresent(questTypeHash, forKey: "questTypeHash")
        try container.encodeIfPresent(questTypeIdentifier, forKey: "questTypeIdentifier")
        try container.encodeIfPresent(questlineItemHash, forKey: "questlineItemHash")
        try container.encodeIfPresent(requireFullObjectiveCompletion, forKey: "requireFullObjectiveCompletion")
    }

    public static func == (lhs: DestinyDefinitionsDestinyItemObjectiveBlockDefinition, rhs: DestinyDefinitionsDestinyItemObjectiveBlockDefinition) -> Bool {
        guard lhs.displayActivityHashes == rhs.displayActivityHashes else { return false }
        guard lhs.narrative == rhs.narrative else { return false }
        guard lhs.objectiveHashes == rhs.objectiveHashes else { return false }
        guard lhs.objectiveVerbName == rhs.objectiveVerbName else { return false }
        guard lhs.perObjectiveDisplayProperties == rhs.perObjectiveDisplayProperties else { return false }
        guard lhs.questTypeHash == rhs.questTypeHash else { return false }
        guard lhs.questTypeIdentifier == rhs.questTypeIdentifier else { return false }
        guard lhs.questlineItemHash == rhs.questlineItemHash else { return false }
        guard lhs.requireFullObjectiveCompletion == rhs.requireFullObjectiveCompletion else { return false }
        return true
    }
}
