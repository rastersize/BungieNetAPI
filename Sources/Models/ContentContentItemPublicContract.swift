//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public struct ContentContentItemPublicContract: APIModel {

    public var allowComments: Bool?

    public var author: UserGeneralUser?

    public var autoEnglishPropertyFallback: Bool?

    public var cType: String?

    public var cmsPath: String?

    public var commentSummary: ContentCommentSummary?

    public var contentId: Int?

    public var creationDate: DateTime?

    public var hasAgeGate: Bool?

    public var minimumAge: Int?

    public var modifyDate: DateTime?

    /** Firehose content is really a collection of metadata and "properties", which are the potentially-but-not-strictly localizable data that comprises the meat of whatever content is being shown.
As Cole Porter would have crooned, "Anything Goes" with Firehose properties. They are most often strings, but they can theoretically be anything. They are JSON encoded, and could be JSON structures, simple strings, numbers etc... The Content Type of the item (cType) will describe the properties, and thus how they ought to be deserialized. */
    public var properties: [String: [String: Any]]?

    public var ratingImagePath: String?

    public var representations: [ContentContentRepresentation]?

    /** NOTE: Tags will always be lower case. */
    public var tags: [String]?

    public init(allowComments: Bool? = nil, author: UserGeneralUser? = nil, autoEnglishPropertyFallback: Bool? = nil, cType: String? = nil, cmsPath: String? = nil, commentSummary: ContentCommentSummary? = nil, contentId: Int? = nil, creationDate: DateTime? = nil, hasAgeGate: Bool? = nil, minimumAge: Int? = nil, modifyDate: DateTime? = nil, properties: [String: [String: Any]]? = nil, ratingImagePath: String? = nil, representations: [ContentContentRepresentation]? = nil, tags: [String]? = nil) {
        self.allowComments = allowComments
        self.author = author
        self.autoEnglishPropertyFallback = autoEnglishPropertyFallback
        self.cType = cType
        self.cmsPath = cmsPath
        self.commentSummary = commentSummary
        self.contentId = contentId
        self.creationDate = creationDate
        self.hasAgeGate = hasAgeGate
        self.minimumAge = minimumAge
        self.modifyDate = modifyDate
        self.properties = properties
        self.ratingImagePath = ratingImagePath
        self.representations = representations
        self.tags = tags
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        allowComments = try container.decodeIfPresent("allowComments")
        author = try container.decodeIfPresent("author")
        autoEnglishPropertyFallback = try container.decodeIfPresent("autoEnglishPropertyFallback")
        cType = try container.decodeIfPresent("cType")
        cmsPath = try container.decodeIfPresent("cmsPath")
        commentSummary = try container.decodeIfPresent("commentSummary")
        contentId = try container.decodeIfPresent("contentId")
        creationDate = try container.decodeIfPresent("creationDate")
        hasAgeGate = try container.decodeIfPresent("hasAgeGate")
        minimumAge = try container.decodeIfPresent("minimumAge")
        modifyDate = try container.decodeIfPresent("modifyDate")
        properties = try container.decodeAnyIfPresent("properties")
        ratingImagePath = try container.decodeIfPresent("ratingImagePath")
        representations = try container.decodeArrayIfPresent("representations")
        tags = try container.decodeArrayIfPresent("tags")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(allowComments, forKey: "allowComments")
        try container.encodeIfPresent(author, forKey: "author")
        try container.encodeIfPresent(autoEnglishPropertyFallback, forKey: "autoEnglishPropertyFallback")
        try container.encodeIfPresent(cType, forKey: "cType")
        try container.encodeIfPresent(cmsPath, forKey: "cmsPath")
        try container.encodeIfPresent(commentSummary, forKey: "commentSummary")
        try container.encodeIfPresent(contentId, forKey: "contentId")
        try container.encodeIfPresent(creationDate, forKey: "creationDate")
        try container.encodeIfPresent(hasAgeGate, forKey: "hasAgeGate")
        try container.encodeIfPresent(minimumAge, forKey: "minimumAge")
        try container.encodeIfPresent(modifyDate, forKey: "modifyDate")
        try container.encodeAnyIfPresent(properties, forKey: "properties")
        try container.encodeIfPresent(ratingImagePath, forKey: "ratingImagePath")
        try container.encodeIfPresent(representations, forKey: "representations")
        try container.encodeIfPresent(tags, forKey: "tags")
    }

    public static func == (lhs: ContentContentItemPublicContract, rhs: ContentContentItemPublicContract) -> Bool {
        guard lhs.allowComments == rhs.allowComments else { return false }
        guard lhs.author == rhs.author else { return false }
        guard lhs.autoEnglishPropertyFallback == rhs.autoEnglishPropertyFallback else { return false }
        guard lhs.cType == rhs.cType else { return false }
        guard lhs.cmsPath == rhs.cmsPath else { return false }
        guard lhs.commentSummary == rhs.commentSummary else { return false }
        guard lhs.contentId == rhs.contentId else { return false }
        guard lhs.creationDate == rhs.creationDate else { return false }
        guard lhs.hasAgeGate == rhs.hasAgeGate else { return false }
        guard lhs.minimumAge == rhs.minimumAge else { return false }
        guard lhs.modifyDate == rhs.modifyDate else { return false }
        guard NSDictionary(dictionary: lhs.properties ?? [:]).isEqual(to: rhs.properties ?? [:]) else { return false }
        guard lhs.ratingImagePath == rhs.ratingImagePath else { return false }
        guard lhs.representations == rhs.representations else { return false }
        guard lhs.tags == rhs.tags else { return false }
        return true
    }
}
