//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** If an item can have an action performed on it (like "Dismantle"), it will be defined here if you care. */
public struct DestinyDefinitionsDestinyItemActionBlockDefinition: APIModel {

    /** The internal identifier for the action. */
    public var actionTypeLabel: String?

    /** If true, the entire stack is deleted when the action completes. */
    public var consumeEntireStack: Bool?

    /** If true, the item is deleted when the action completes. */
    public var deleteOnAction: Bool?

    /** The content has this property, however it's not entirely clear how it is used. */
    public var isPositive: Bool?

    /** The icon associated with the overlay screen for the action, if any. */
    public var overlayIcon: String?

    /** If the action has an overlay screen associated with it, this is the name of that screen. Unfortunately, we cannot return the screen's data itself. */
    public var overlayScreenName: String?

    /** If performing this action earns you Progression, this is the list of progressions and values granted for those progressions by performing this action. */
    public var progressionRewards: [DestinyDefinitionsDestinyProgressionRewardDefinition]?

    /** The identifier hash for the Cooldown associated with this action. We have not pulled this data yet for you to have more data to use for cooldowns. */
    public var requiredCooldownHash: Int?

    /** The number of seconds to delay before allowing this action to be performed again. */
    public var requiredCooldownSeconds: Int?

    /** If the action requires other items to exist or be destroyed, this is the list of those items and requirements. */
    public var requiredItems: [DestinyDefinitionsDestinyItemActionRequiredItemDefinition]?

    /** Theoretically, an item could have a localized string for a hint about the location in which the action should be performed. In practice, no items yet have this property. */
    public var requiredLocation: String?

    /** If true, this action will be performed as soon as you earn this item. Some rewards work this way, providing you a single item to pick up from a reward-granting vendor in-game and then immediately consuming itself to provide you multiple items. */
    public var useOnAcquire: Bool?

    /** Localized text describing the action being performed. */
    public var verbDescription: String?

    /** Localized text for the verb of the action being performed. */
    public var verbName: String?

    public init(actionTypeLabel: String? = nil, consumeEntireStack: Bool? = nil, deleteOnAction: Bool? = nil, isPositive: Bool? = nil, overlayIcon: String? = nil, overlayScreenName: String? = nil, progressionRewards: [DestinyDefinitionsDestinyProgressionRewardDefinition]? = nil, requiredCooldownHash: Int? = nil, requiredCooldownSeconds: Int? = nil, requiredItems: [DestinyDefinitionsDestinyItemActionRequiredItemDefinition]? = nil, requiredLocation: String? = nil, useOnAcquire: Bool? = nil, verbDescription: String? = nil, verbName: String? = nil) {
        self.actionTypeLabel = actionTypeLabel
        self.consumeEntireStack = consumeEntireStack
        self.deleteOnAction = deleteOnAction
        self.isPositive = isPositive
        self.overlayIcon = overlayIcon
        self.overlayScreenName = overlayScreenName
        self.progressionRewards = progressionRewards
        self.requiredCooldownHash = requiredCooldownHash
        self.requiredCooldownSeconds = requiredCooldownSeconds
        self.requiredItems = requiredItems
        self.requiredLocation = requiredLocation
        self.useOnAcquire = useOnAcquire
        self.verbDescription = verbDescription
        self.verbName = verbName
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        actionTypeLabel = try container.decodeIfPresent("actionTypeLabel")
        consumeEntireStack = try container.decodeIfPresent("consumeEntireStack")
        deleteOnAction = try container.decodeIfPresent("deleteOnAction")
        isPositive = try container.decodeIfPresent("isPositive")
        overlayIcon = try container.decodeIfPresent("overlayIcon")
        overlayScreenName = try container.decodeIfPresent("overlayScreenName")
        progressionRewards = try container.decodeArrayIfPresent("progressionRewards")
        requiredCooldownHash = try container.decodeIfPresent("requiredCooldownHash")
        requiredCooldownSeconds = try container.decodeIfPresent("requiredCooldownSeconds")
        requiredItems = try container.decodeArrayIfPresent("requiredItems")
        requiredLocation = try container.decodeIfPresent("requiredLocation")
        useOnAcquire = try container.decodeIfPresent("useOnAcquire")
        verbDescription = try container.decodeIfPresent("verbDescription")
        verbName = try container.decodeIfPresent("verbName")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(actionTypeLabel, forKey: "actionTypeLabel")
        try container.encodeIfPresent(consumeEntireStack, forKey: "consumeEntireStack")
        try container.encodeIfPresent(deleteOnAction, forKey: "deleteOnAction")
        try container.encodeIfPresent(isPositive, forKey: "isPositive")
        try container.encodeIfPresent(overlayIcon, forKey: "overlayIcon")
        try container.encodeIfPresent(overlayScreenName, forKey: "overlayScreenName")
        try container.encodeIfPresent(progressionRewards, forKey: "progressionRewards")
        try container.encodeIfPresent(requiredCooldownHash, forKey: "requiredCooldownHash")
        try container.encodeIfPresent(requiredCooldownSeconds, forKey: "requiredCooldownSeconds")
        try container.encodeIfPresent(requiredItems, forKey: "requiredItems")
        try container.encodeIfPresent(requiredLocation, forKey: "requiredLocation")
        try container.encodeIfPresent(useOnAcquire, forKey: "useOnAcquire")
        try container.encodeIfPresent(verbDescription, forKey: "verbDescription")
        try container.encodeIfPresent(verbName, forKey: "verbName")
    }

    public static func == (lhs: DestinyDefinitionsDestinyItemActionBlockDefinition, rhs: DestinyDefinitionsDestinyItemActionBlockDefinition) -> Bool {
        guard lhs.actionTypeLabel == rhs.actionTypeLabel else { return false }
        guard lhs.consumeEntireStack == rhs.consumeEntireStack else { return false }
        guard lhs.deleteOnAction == rhs.deleteOnAction else { return false }
        guard lhs.isPositive == rhs.isPositive else { return false }
        guard lhs.overlayIcon == rhs.overlayIcon else { return false }
        guard lhs.overlayScreenName == rhs.overlayScreenName else { return false }
        guard lhs.progressionRewards == rhs.progressionRewards else { return false }
        guard lhs.requiredCooldownHash == rhs.requiredCooldownHash else { return false }
        guard lhs.requiredCooldownSeconds == rhs.requiredCooldownSeconds else { return false }
        guard lhs.requiredItems == rhs.requiredItems else { return false }
        guard lhs.requiredLocation == rhs.requiredLocation else { return false }
        guard lhs.useOnAcquire == rhs.useOnAcquire else { return false }
        guard lhs.verbDescription == rhs.verbDescription else { return false }
        guard lhs.verbName == rhs.verbName else { return false }
        return true
    }
}
