//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** Information about milestones, presented in a character state-agnostic manner. Combine this data with DestinyMilestoneDefinition to get a full picture of the milestone, which is basically a checklist of things to do in the game. Think of this as GetPublicAdvisors 3.0, for those who used the Destiny 1 API. */
public struct DestinyMilestonesDestinyPublicMilestone: APIModel {

    public var activities: [DestinyMilestonesDestinyPublicMilestoneChallengeActivity]?

    /** A milestone not need have even a single quest, but if there are active quests they will be returned here. */
    public var availableQuests: [DestinyMilestonesDestinyPublicMilestoneQuest]?

    /** If known, this is the date when the Milestone will expire/recycle/end. */
    public var endDate: DateTime?

    /** The hash identifier for the milestone. Use it to look up the DestinyMilestoneDefinition for static data about the Milestone. */
    public var milestoneHash: Int?

    /** Used for ordering milestones in a display to match how we order them in BNet. May pull from static data, or possibly in the future from dynamic information. */
    public var order: Int?

    /** If known, this is the date when the Milestone started/became active. */
    public var startDate: DateTime?

    /** Sometimes milestones - or activities active in milestones - will have relevant vendors. These are the vendors that are currently relevant.
Deprecated, already, for the sake of the new "vendors" property that has more data. What was I thinking. */
    public var vendorHashes: [Int]?

    /** This is why we can't have nice things. This is the ordered list of vendors to be shown that relate to this milestone, potentially along with other interesting data. */
    public var vendors: [DestinyMilestonesDestinyPublicMilestoneVendor]?

    public init(activities: [DestinyMilestonesDestinyPublicMilestoneChallengeActivity]? = nil, availableQuests: [DestinyMilestonesDestinyPublicMilestoneQuest]? = nil, endDate: DateTime? = nil, milestoneHash: Int? = nil, order: Int? = nil, startDate: DateTime? = nil, vendorHashes: [Int]? = nil, vendors: [DestinyMilestonesDestinyPublicMilestoneVendor]? = nil) {
        self.activities = activities
        self.availableQuests = availableQuests
        self.endDate = endDate
        self.milestoneHash = milestoneHash
        self.order = order
        self.startDate = startDate
        self.vendorHashes = vendorHashes
        self.vendors = vendors
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        activities = try container.decodeArrayIfPresent("activities")
        availableQuests = try container.decodeArrayIfPresent("availableQuests")
        endDate = try container.decodeIfPresent("endDate")
        milestoneHash = try container.decodeIfPresent("milestoneHash")
        order = try container.decodeIfPresent("order")
        startDate = try container.decodeIfPresent("startDate")
        vendorHashes = try container.decodeArrayIfPresent("vendorHashes")
        vendors = try container.decodeArrayIfPresent("vendors")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(activities, forKey: "activities")
        try container.encodeIfPresent(availableQuests, forKey: "availableQuests")
        try container.encodeIfPresent(endDate, forKey: "endDate")
        try container.encodeIfPresent(milestoneHash, forKey: "milestoneHash")
        try container.encodeIfPresent(order, forKey: "order")
        try container.encodeIfPresent(startDate, forKey: "startDate")
        try container.encodeIfPresent(vendorHashes, forKey: "vendorHashes")
        try container.encodeIfPresent(vendors, forKey: "vendors")
    }

    public static func == (lhs: DestinyMilestonesDestinyPublicMilestone, rhs: DestinyMilestonesDestinyPublicMilestone) -> Bool {
        guard lhs.activities == rhs.activities else { return false }
        guard lhs.availableQuests == rhs.availableQuests else { return false }
        guard lhs.endDate == rhs.endDate else { return false }
        guard lhs.milestoneHash == rhs.milestoneHash else { return false }
        guard lhs.order == rhs.order else { return false }
        guard lhs.startDate == rhs.startDate else { return false }
        guard lhs.vendorHashes == rhs.vendorHashes else { return false }
        guard lhs.vendors == rhs.vendors else { return false }
        return true
    }
}
