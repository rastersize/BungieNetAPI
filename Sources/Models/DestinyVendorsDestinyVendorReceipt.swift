//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** If a character purchased an item that is refundable, a Vendor Receipt will be created on the user's Destiny Profile. These expire after a configurable period of time, but until then can be used to get refunds on items. BNet does not provide the ability to refund a purchase *yet*, but you know. */
public struct DestinyVendorsDestinyVendorReceipt: APIModel {

    /** The amount paid for the item, in terms of items that were consumed in the purchase and their quantity. */
    public var currencyPaid: [DestinyDestinyItemQuantity]?

    /** The date at which this receipt is rendered invalid. */
    public var expiresOn: DateTime?

    /** The item that was received, and its quantity. */
    public var itemReceived: [String: Any]?

    /** The unlock flag used to determine whether you still have the purchased item. */
    public var licenseUnlockHash: Int?

    /** The ID of the character who made the purchase. */
    public var purchasedByCharacterId: Int?

    /** Whether you can get a refund, and what happens in order for the refund to be received. See the DestinyVendorItemRefundPolicy enum for details. */
    public var refundPolicy: Int?

    /** The identifier of this receipt. */
    public var sequenceNumber: Int?

    /** The seconds since epoch at which this receipt is rendered invalid. */
    public var timeToExpiration: Int?

    public init(currencyPaid: [DestinyDestinyItemQuantity]? = nil, expiresOn: DateTime? = nil, itemReceived: [String: Any]? = nil, licenseUnlockHash: Int? = nil, purchasedByCharacterId: Int? = nil, refundPolicy: Int? = nil, sequenceNumber: Int? = nil, timeToExpiration: Int? = nil) {
        self.currencyPaid = currencyPaid
        self.expiresOn = expiresOn
        self.itemReceived = itemReceived
        self.licenseUnlockHash = licenseUnlockHash
        self.purchasedByCharacterId = purchasedByCharacterId
        self.refundPolicy = refundPolicy
        self.sequenceNumber = sequenceNumber
        self.timeToExpiration = timeToExpiration
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        currencyPaid = try container.decodeArrayIfPresent("currencyPaid")
        expiresOn = try container.decodeIfPresent("expiresOn")
        itemReceived = try container.decodeAnyIfPresent("itemReceived")
        licenseUnlockHash = try container.decodeIfPresent("licenseUnlockHash")
        purchasedByCharacterId = try container.decodeIfPresent("purchasedByCharacterId")
        refundPolicy = try container.decodeIfPresent("refundPolicy")
        sequenceNumber = try container.decodeIfPresent("sequenceNumber")
        timeToExpiration = try container.decodeIfPresent("timeToExpiration")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(currencyPaid, forKey: "currencyPaid")
        try container.encodeIfPresent(expiresOn, forKey: "expiresOn")
        try container.encodeAnyIfPresent(itemReceived, forKey: "itemReceived")
        try container.encodeIfPresent(licenseUnlockHash, forKey: "licenseUnlockHash")
        try container.encodeIfPresent(purchasedByCharacterId, forKey: "purchasedByCharacterId")
        try container.encodeIfPresent(refundPolicy, forKey: "refundPolicy")
        try container.encodeIfPresent(sequenceNumber, forKey: "sequenceNumber")
        try container.encodeIfPresent(timeToExpiration, forKey: "timeToExpiration")
    }

    public static func == (lhs: DestinyVendorsDestinyVendorReceipt, rhs: DestinyVendorsDestinyVendorReceipt) -> Bool {
        guard lhs.currencyPaid == rhs.currencyPaid else { return false }
        guard lhs.expiresOn == rhs.expiresOn else { return false }
        guard NSDictionary(dictionary: lhs.itemReceived ?? [:]).isEqual(to: rhs.itemReceived ?? [:]) else { return false }
        guard lhs.licenseUnlockHash == rhs.licenseUnlockHash else { return false }
        guard lhs.purchasedByCharacterId == rhs.purchasedByCharacterId else { return false }
        guard lhs.refundPolicy == rhs.refundPolicy else { return false }
        guard lhs.sequenceNumber == rhs.sequenceNumber else { return false }
        guard lhs.timeToExpiration == rhs.timeToExpiration else { return false }
        return true
    }
}
