//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** A specific "spot" referred to by a location. Only one of these can be active at a time for a given Location. */
public struct DestinyDefinitionsDestinyLocationReleaseDefinition: APIModel {

    /** The Activity Bubble within the Destination. Look this up in the DestinyDestinationDefinition's bubbles and bubbleSettings properties. */
    public var activityBubbleName: Int?

    /** The Activity Graph being pointed to by this location. */
    public var activityGraphHash: Int?

    /** The Activity Graph Node being pointed to by this location. (Remember that Activity Graph Node hashes are only unique within an Activity Graph: so use the combination to find the node being spoken of) */
    public var activityGraphNodeHash: Int?

    /** The Activity being pointed to by this location. */
    public var activityHash: Int?

    /** If we had map information, this would tell us something cool about the path this location wants you to take. I wish we had map information. */
    public var activityPathBundle: Int?

    /** If we had map information, this would tell us about path information related to destination on the map. Sad. Maybe you can do something cool with it. Go to town man. */
    public var activityPathDestination: Int?

    /** The Destination being pointed to by this location. */
    public var destinationHash: Int?

    /** Sadly, these don't appear to be populated anymore (ever?) */
    public var displayProperties: [String: Any]?

    public var largeTransparentIcon: String?

    public var mapIcon: String?

    /** The type of Nav Point that this represents. See the enumeration for more info. */
    public var navPointType: Int?

    public var smallTransparentIcon: String?

    /** If we had map information, this spawnPoint would be interesting. But sadly, we don't have that info. */
    public var spawnPoint: Int?

    /** Looks like it should be the position on the map, but sadly it does not look populated... yet? */
    public var worldPosition: [Int]?

    public init(activityBubbleName: Int? = nil, activityGraphHash: Int? = nil, activityGraphNodeHash: Int? = nil, activityHash: Int? = nil, activityPathBundle: Int? = nil, activityPathDestination: Int? = nil, destinationHash: Int? = nil, displayProperties: [String: Any]? = nil, largeTransparentIcon: String? = nil, mapIcon: String? = nil, navPointType: Int? = nil, smallTransparentIcon: String? = nil, spawnPoint: Int? = nil, worldPosition: [Int]? = nil) {
        self.activityBubbleName = activityBubbleName
        self.activityGraphHash = activityGraphHash
        self.activityGraphNodeHash = activityGraphNodeHash
        self.activityHash = activityHash
        self.activityPathBundle = activityPathBundle
        self.activityPathDestination = activityPathDestination
        self.destinationHash = destinationHash
        self.displayProperties = displayProperties
        self.largeTransparentIcon = largeTransparentIcon
        self.mapIcon = mapIcon
        self.navPointType = navPointType
        self.smallTransparentIcon = smallTransparentIcon
        self.spawnPoint = spawnPoint
        self.worldPosition = worldPosition
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        activityBubbleName = try container.decodeIfPresent("activityBubbleName")
        activityGraphHash = try container.decodeIfPresent("activityGraphHash")
        activityGraphNodeHash = try container.decodeIfPresent("activityGraphNodeHash")
        activityHash = try container.decodeIfPresent("activityHash")
        activityPathBundle = try container.decodeIfPresent("activityPathBundle")
        activityPathDestination = try container.decodeIfPresent("activityPathDestination")
        destinationHash = try container.decodeIfPresent("destinationHash")
        displayProperties = try container.decodeAnyIfPresent("displayProperties")
        largeTransparentIcon = try container.decodeIfPresent("largeTransparentIcon")
        mapIcon = try container.decodeIfPresent("mapIcon")
        navPointType = try container.decodeIfPresent("navPointType")
        smallTransparentIcon = try container.decodeIfPresent("smallTransparentIcon")
        spawnPoint = try container.decodeIfPresent("spawnPoint")
        worldPosition = try container.decodeArrayIfPresent("worldPosition")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(activityBubbleName, forKey: "activityBubbleName")
        try container.encodeIfPresent(activityGraphHash, forKey: "activityGraphHash")
        try container.encodeIfPresent(activityGraphNodeHash, forKey: "activityGraphNodeHash")
        try container.encodeIfPresent(activityHash, forKey: "activityHash")
        try container.encodeIfPresent(activityPathBundle, forKey: "activityPathBundle")
        try container.encodeIfPresent(activityPathDestination, forKey: "activityPathDestination")
        try container.encodeIfPresent(destinationHash, forKey: "destinationHash")
        try container.encodeAnyIfPresent(displayProperties, forKey: "displayProperties")
        try container.encodeIfPresent(largeTransparentIcon, forKey: "largeTransparentIcon")
        try container.encodeIfPresent(mapIcon, forKey: "mapIcon")
        try container.encodeIfPresent(navPointType, forKey: "navPointType")
        try container.encodeIfPresent(smallTransparentIcon, forKey: "smallTransparentIcon")
        try container.encodeIfPresent(spawnPoint, forKey: "spawnPoint")
        try container.encodeIfPresent(worldPosition, forKey: "worldPosition")
    }

    public static func == (lhs: DestinyDefinitionsDestinyLocationReleaseDefinition, rhs: DestinyDefinitionsDestinyLocationReleaseDefinition) -> Bool {
        guard lhs.activityBubbleName == rhs.activityBubbleName else { return false }
        guard lhs.activityGraphHash == rhs.activityGraphHash else { return false }
        guard lhs.activityGraphNodeHash == rhs.activityGraphNodeHash else { return false }
        guard lhs.activityHash == rhs.activityHash else { return false }
        guard lhs.activityPathBundle == rhs.activityPathBundle else { return false }
        guard lhs.activityPathDestination == rhs.activityPathDestination else { return false }
        guard lhs.destinationHash == rhs.destinationHash else { return false }
        guard NSDictionary(dictionary: lhs.displayProperties ?? [:]).isEqual(to: rhs.displayProperties ?? [:]) else { return false }
        guard lhs.largeTransparentIcon == rhs.largeTransparentIcon else { return false }
        guard lhs.mapIcon == rhs.mapIcon else { return false }
        guard lhs.navPointType == rhs.navPointType else { return false }
        guard lhs.smallTransparentIcon == rhs.smallTransparentIcon else { return false }
        guard lhs.spawnPoint == rhs.spawnPoint else { return false }
        guard lhs.worldPosition == rhs.worldPosition else { return false }
        return true
    }
}
