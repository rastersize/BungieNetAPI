//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** This represents an item being sold by the vendor. */
public struct DestinyDefinitionsDestinyVendorItemDefinition: APIModel {

    /** The action to be performed when purchasing the item, if it's not just "buy". */
    public var action: [String: Any]?

    /** The index into the DestinyVendorDefinition.categories array, so you can find the category associated with this item. */
    public var categoryIndex: Int?

    /** The Default level at which the item will spawn. Almost always driven by an adjusto these days. Ideally should be singular. It's a long story how this ended up as a list, but there is always either going to be 0:1 of these entities. */
    public var creationLevels: [DestinyDefinitionsDestinyItemCreationEntryLevelDefinition]?

    /** This is a pre-compiled aggregation of item value and priceOverrideList, so that we have one place to check for what the purchaser must pay for the item. Use this instead of trying to piece together the price separately.
The somewhat crappy part about this is that, now that item quantity overrides have dynamic modifiers, this will not necessarily be statically true. If you were using this instead of live data, switch to using live data. */
    public var currencies: [DestinyDefinitionsDestinyVendorItemQuantity]?

    /** The string identifier for the category selling this item. */
    public var displayCategory: String?

    /** This is an index specifically into the display category, as opposed to the server-side Categories (which do not need to match or pair with each other in any way: server side categories are really just structures for common validation. Display Category will let us more easily categorize items visually) */
    public var displayCategoryIndex: Int?

    /** If this item can only be purchased by a given platform, this indicates the platform to which it is restricted. */
    public var exclusivity: Int?

    /** If this item can expire, this is the tooltip message to show with its expiration info. */
    public var expirationTooltip: String?

    /** An list of indexes into the DestinyVendorDefinition.failureStrings array, indicating the possible failure strings that can be relevant for this item. */
    public var failureIndexes: [Int]?

    /** The inventory bucket into which this item will be placed upon purchase. */
    public var inventoryBucketHash: Int?

    /** If this sale can only be performed as the result of receiving a CRM offer, this is true. */
    public var isCrm: Bool?

    /** If this sale can only be performed as the result of an offer check, this is true. */
    public var isOffer: Bool?

    /** The hash identifier of the item being sold (DestinyInventoryItemDefinition).
Note that a vendor can sell the same item in multiple ways, so don't assume that itemHash is a unique identifier for this entity. */
    public var itemHash: Int?

    /** The maximum character level at which this item is available for sale. */
    public var maximumLevel: Int?

    /** The minimum character level at which this item is available for sale. */
    public var minimumLevel: Int?

    /** Same as above, but for the original category indexes. */
    public var originalCategoryIndex: Int?

    /** Similar to visibilityScope, it represents the most restrictive scope that determines whether the item can be purchased. It will at least be as restrictive as visibilityScope, but could be more restrictive if the item has additional purchase requirements beyond whether it is merely visible or not.
See DestinyGatingScope's documentation for more information. */
    public var purchasableScope: Int?

    /** The amount you will recieve of the item described in itemHash if you make the purchase. */
    public var quantity: Int?

    /** If this is populated, the purchase of this item should redirect to purchasing these other items instead. */
    public var redirectToSaleIndexes: [Int]?

    /** If this item can be refunded, this is the policy for what will be refundd, how, and in what time period. */
    public var refundPolicy: Int?

    /** The amount of time before refundability of the newly purchased item will expire. */
    public var refundTimeLimit: Int?

    public var socketOverrides: [DestinyDefinitionsDestinyVendorItemSocketOverride]?

    /** *if* the category this item is in supports non-default sorting, this value should represent the sorting value to use, pre-processed and ready to go. */
    public var sortValue: Int?

    /** The index into the DestinyVendorDefinition.saleList. This is what we use to refer to items being sold throughout live and definition data. */
    public var vendorItemIndex: Int?

    /** The most restrictive scope that determines whether the item is available in the Vendor's inventory. See DestinyGatingScope's documentation for more information.
This can be determined by Unlock gating, or by whether or not the item has purchase level requirements (minimumLevel and maximumLevel properties). */
    public var visibilityScope: Int?

    public init(action: [String: Any]? = nil, categoryIndex: Int? = nil, creationLevels: [DestinyDefinitionsDestinyItemCreationEntryLevelDefinition]? = nil, currencies: [DestinyDefinitionsDestinyVendorItemQuantity]? = nil, displayCategory: String? = nil, displayCategoryIndex: Int? = nil, exclusivity: Int? = nil, expirationTooltip: String? = nil, failureIndexes: [Int]? = nil, inventoryBucketHash: Int? = nil, isCrm: Bool? = nil, isOffer: Bool? = nil, itemHash: Int? = nil, maximumLevel: Int? = nil, minimumLevel: Int? = nil, originalCategoryIndex: Int? = nil, purchasableScope: Int? = nil, quantity: Int? = nil, redirectToSaleIndexes: [Int]? = nil, refundPolicy: Int? = nil, refundTimeLimit: Int? = nil, socketOverrides: [DestinyDefinitionsDestinyVendorItemSocketOverride]? = nil, sortValue: Int? = nil, vendorItemIndex: Int? = nil, visibilityScope: Int? = nil) {
        self.action = action
        self.categoryIndex = categoryIndex
        self.creationLevels = creationLevels
        self.currencies = currencies
        self.displayCategory = displayCategory
        self.displayCategoryIndex = displayCategoryIndex
        self.exclusivity = exclusivity
        self.expirationTooltip = expirationTooltip
        self.failureIndexes = failureIndexes
        self.inventoryBucketHash = inventoryBucketHash
        self.isCrm = isCrm
        self.isOffer = isOffer
        self.itemHash = itemHash
        self.maximumLevel = maximumLevel
        self.minimumLevel = minimumLevel
        self.originalCategoryIndex = originalCategoryIndex
        self.purchasableScope = purchasableScope
        self.quantity = quantity
        self.redirectToSaleIndexes = redirectToSaleIndexes
        self.refundPolicy = refundPolicy
        self.refundTimeLimit = refundTimeLimit
        self.socketOverrides = socketOverrides
        self.sortValue = sortValue
        self.vendorItemIndex = vendorItemIndex
        self.visibilityScope = visibilityScope
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        action = try container.decodeAnyIfPresent("action")
        categoryIndex = try container.decodeIfPresent("categoryIndex")
        creationLevels = try container.decodeArrayIfPresent("creationLevels")
        currencies = try container.decodeArrayIfPresent("currencies")
        displayCategory = try container.decodeIfPresent("displayCategory")
        displayCategoryIndex = try container.decodeIfPresent("displayCategoryIndex")
        exclusivity = try container.decodeIfPresent("exclusivity")
        expirationTooltip = try container.decodeIfPresent("expirationTooltip")
        failureIndexes = try container.decodeArrayIfPresent("failureIndexes")
        inventoryBucketHash = try container.decodeIfPresent("inventoryBucketHash")
        isCrm = try container.decodeIfPresent("isCrm")
        isOffer = try container.decodeIfPresent("isOffer")
        itemHash = try container.decodeIfPresent("itemHash")
        maximumLevel = try container.decodeIfPresent("maximumLevel")
        minimumLevel = try container.decodeIfPresent("minimumLevel")
        originalCategoryIndex = try container.decodeIfPresent("originalCategoryIndex")
        purchasableScope = try container.decodeIfPresent("purchasableScope")
        quantity = try container.decodeIfPresent("quantity")
        redirectToSaleIndexes = try container.decodeArrayIfPresent("redirectToSaleIndexes")
        refundPolicy = try container.decodeIfPresent("refundPolicy")
        refundTimeLimit = try container.decodeIfPresent("refundTimeLimit")
        socketOverrides = try container.decodeArrayIfPresent("socketOverrides")
        sortValue = try container.decodeIfPresent("sortValue")
        vendorItemIndex = try container.decodeIfPresent("vendorItemIndex")
        visibilityScope = try container.decodeIfPresent("visibilityScope")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeAnyIfPresent(action, forKey: "action")
        try container.encodeIfPresent(categoryIndex, forKey: "categoryIndex")
        try container.encodeIfPresent(creationLevels, forKey: "creationLevels")
        try container.encodeIfPresent(currencies, forKey: "currencies")
        try container.encodeIfPresent(displayCategory, forKey: "displayCategory")
        try container.encodeIfPresent(displayCategoryIndex, forKey: "displayCategoryIndex")
        try container.encodeIfPresent(exclusivity, forKey: "exclusivity")
        try container.encodeIfPresent(expirationTooltip, forKey: "expirationTooltip")
        try container.encodeIfPresent(failureIndexes, forKey: "failureIndexes")
        try container.encodeIfPresent(inventoryBucketHash, forKey: "inventoryBucketHash")
        try container.encodeIfPresent(isCrm, forKey: "isCrm")
        try container.encodeIfPresent(isOffer, forKey: "isOffer")
        try container.encodeIfPresent(itemHash, forKey: "itemHash")
        try container.encodeIfPresent(maximumLevel, forKey: "maximumLevel")
        try container.encodeIfPresent(minimumLevel, forKey: "minimumLevel")
        try container.encodeIfPresent(originalCategoryIndex, forKey: "originalCategoryIndex")
        try container.encodeIfPresent(purchasableScope, forKey: "purchasableScope")
        try container.encodeIfPresent(quantity, forKey: "quantity")
        try container.encodeIfPresent(redirectToSaleIndexes, forKey: "redirectToSaleIndexes")
        try container.encodeIfPresent(refundPolicy, forKey: "refundPolicy")
        try container.encodeIfPresent(refundTimeLimit, forKey: "refundTimeLimit")
        try container.encodeIfPresent(socketOverrides, forKey: "socketOverrides")
        try container.encodeIfPresent(sortValue, forKey: "sortValue")
        try container.encodeIfPresent(vendorItemIndex, forKey: "vendorItemIndex")
        try container.encodeIfPresent(visibilityScope, forKey: "visibilityScope")
    }

    public static func == (lhs: DestinyDefinitionsDestinyVendorItemDefinition, rhs: DestinyDefinitionsDestinyVendorItemDefinition) -> Bool {
        guard NSDictionary(dictionary: lhs.action ?? [:]).isEqual(to: rhs.action ?? [:]) else { return false }
        guard lhs.categoryIndex == rhs.categoryIndex else { return false }
        guard lhs.creationLevels == rhs.creationLevels else { return false }
        guard lhs.currencies == rhs.currencies else { return false }
        guard lhs.displayCategory == rhs.displayCategory else { return false }
        guard lhs.displayCategoryIndex == rhs.displayCategoryIndex else { return false }
        guard lhs.exclusivity == rhs.exclusivity else { return false }
        guard lhs.expirationTooltip == rhs.expirationTooltip else { return false }
        guard lhs.failureIndexes == rhs.failureIndexes else { return false }
        guard lhs.inventoryBucketHash == rhs.inventoryBucketHash else { return false }
        guard lhs.isCrm == rhs.isCrm else { return false }
        guard lhs.isOffer == rhs.isOffer else { return false }
        guard lhs.itemHash == rhs.itemHash else { return false }
        guard lhs.maximumLevel == rhs.maximumLevel else { return false }
        guard lhs.minimumLevel == rhs.minimumLevel else { return false }
        guard lhs.originalCategoryIndex == rhs.originalCategoryIndex else { return false }
        guard lhs.purchasableScope == rhs.purchasableScope else { return false }
        guard lhs.quantity == rhs.quantity else { return false }
        guard lhs.redirectToSaleIndexes == rhs.redirectToSaleIndexes else { return false }
        guard lhs.refundPolicy == rhs.refundPolicy else { return false }
        guard lhs.refundTimeLimit == rhs.refundTimeLimit else { return false }
        guard lhs.socketOverrides == rhs.socketOverrides else { return false }
        guard lhs.sortValue == rhs.sortValue else { return false }
        guard lhs.vendorItemIndex == rhs.vendorItemIndex else { return false }
        guard lhs.visibilityScope == rhs.visibilityScope else { return false }
        return true
    }
}
