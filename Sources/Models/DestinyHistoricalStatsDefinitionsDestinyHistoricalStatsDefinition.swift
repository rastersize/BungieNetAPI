//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public struct DestinyHistoricalStatsDefinitionsDestinyHistoricalStatsDefinition: APIModel {

    /** Optional icon for the statistic */
    public enum MergeMethod: Int, Codable, Equatable, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
    }

    /** Category for the stat. */
    public var category: Int?

    /** Statistic group */
    public var group: Int?

    /** Optional URI to an icon for the statistic */
    public var iconImage: String?

    /** The tier associated with this medal - be it implicitly or explicitly. */
    public var medalTierHash: Int?

    /** Optional icon for the statistic */
    public var mergeMethod: MergeMethod?

    /** Game modes where this statistic can be reported. */
    public var modes: [Int]?

    /** Time periods the statistic covers */
    public var periodTypes: [Int]?

    /** Description of a stat if applicable. */
    public var statDescription: String?

    /** Unique programmer friendly ID for this stat */
    public var statId: String?

    /** Display name */
    public var statName: String?

    /** Display name abbreviated */
    public var statNameAbbr: String?

    /** Localized Unit Name for the stat. */
    public var unitLabel: String?

    /** Unit, if any, for the statistic */
    public var unitType: Int?

    /** Weight assigned to this stat indicating its relative impressiveness. */
    public var weight: Int?

    public init(category: Int? = nil, group: Int? = nil, iconImage: String? = nil, medalTierHash: Int? = nil, mergeMethod: MergeMethod? = nil, modes: [Int]? = nil, periodTypes: [Int]? = nil, statDescription: String? = nil, statId: String? = nil, statName: String? = nil, statNameAbbr: String? = nil, unitLabel: String? = nil, unitType: Int? = nil, weight: Int? = nil) {
        self.category = category
        self.group = group
        self.iconImage = iconImage
        self.medalTierHash = medalTierHash
        self.mergeMethod = mergeMethod
        self.modes = modes
        self.periodTypes = periodTypes
        self.statDescription = statDescription
        self.statId = statId
        self.statName = statName
        self.statNameAbbr = statNameAbbr
        self.unitLabel = unitLabel
        self.unitType = unitType
        self.weight = weight
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        category = try container.decodeIfPresent("category")
        group = try container.decodeIfPresent("group")
        iconImage = try container.decodeIfPresent("iconImage")
        medalTierHash = try container.decodeIfPresent("medalTierHash")
        mergeMethod = try container.decodeIfPresent("mergeMethod")
        modes = try container.decodeArrayIfPresent("modes")
        periodTypes = try container.decodeArrayIfPresent("periodTypes")
        statDescription = try container.decodeIfPresent("statDescription")
        statId = try container.decodeIfPresent("statId")
        statName = try container.decodeIfPresent("statName")
        statNameAbbr = try container.decodeIfPresent("statNameAbbr")
        unitLabel = try container.decodeIfPresent("unitLabel")
        unitType = try container.decodeIfPresent("unitType")
        weight = try container.decodeIfPresent("weight")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(category, forKey: "category")
        try container.encodeIfPresent(group, forKey: "group")
        try container.encodeIfPresent(iconImage, forKey: "iconImage")
        try container.encodeIfPresent(medalTierHash, forKey: "medalTierHash")
        try container.encodeIfPresent(mergeMethod, forKey: "mergeMethod")
        try container.encodeIfPresent(modes, forKey: "modes")
        try container.encodeIfPresent(periodTypes, forKey: "periodTypes")
        try container.encodeIfPresent(statDescription, forKey: "statDescription")
        try container.encodeIfPresent(statId, forKey: "statId")
        try container.encodeIfPresent(statName, forKey: "statName")
        try container.encodeIfPresent(statNameAbbr, forKey: "statNameAbbr")
        try container.encodeIfPresent(unitLabel, forKey: "unitLabel")
        try container.encodeIfPresent(unitType, forKey: "unitType")
        try container.encodeIfPresent(weight, forKey: "weight")
    }

    public static func == (lhs: DestinyHistoricalStatsDefinitionsDestinyHistoricalStatsDefinition, rhs: DestinyHistoricalStatsDefinitionsDestinyHistoricalStatsDefinition) -> Bool {
        guard lhs.category == rhs.category else { return false }
        guard lhs.group == rhs.group else { return false }
        guard lhs.iconImage == rhs.iconImage else { return false }
        guard lhs.medalTierHash == rhs.medalTierHash else { return false }
        guard lhs.mergeMethod == rhs.mergeMethod else { return false }
        guard lhs.modes == rhs.modes else { return false }
        guard lhs.periodTypes == rhs.periodTypes else { return false }
        guard lhs.statDescription == rhs.statDescription else { return false }
        guard lhs.statId == rhs.statId else { return false }
        guard lhs.statName == rhs.statName else { return false }
        guard lhs.statNameAbbr == rhs.statNameAbbr else { return false }
        guard lhs.unitLabel == rhs.unitLabel else { return false }
        guard lhs.unitType == rhs.unitType else { return false }
        guard lhs.weight == rhs.weight else { return false }
        return true
    }
}
