//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** If the item can exist in an inventory - the overwhelming majority of them can and do - then this is the basic properties regarding the item's relationship with the inventory. */
public struct DestinyDefinitionsDestinyItemInventoryBlockDefinition: APIModel {

    /** The hash identifier for the DestinyInventoryBucketDefinition to which this item belongs. I should have named this "bucketHash", but too many things refer to it now. Sigh. */
    public var bucketTypeHash: Int?

    /** The tooltip message to show, if any, when the item expires. */
    public var expirationTooltip: String?

    /** If the item expires while playing in an activity, we show a different message. */
    public var expiredInActivityMessage: String?

    /** If the item expires in orbit, we show a... more different message. ("Consummate V's, consummate!") */
    public var expiredInOrbitMessage: String?

    /** If TRUE, this item is instanced. Otherwise, it is a generic item that merely has a quantity in a stack (like Glimmer). */
    public var isInstanceItem: Bool?

    /** The maximum quantity of this item that can exist in a stack. */
    public var maxStackSize: Int?

    /** If the item is picked up by the lost loot queue, this is the hash identifier for the DestinyInventoryBucketDefinition into which it will be placed. Again, I should have named this recoveryBucketHash instead. */
    public var recoveryBucketTypeHash: Int?

    /** If this string is populated, you can't have more than one stack with this label in a given inventory. Note that this is different from the equipping block's unique label, which is used for equipping uniqueness. */
    public var stackUniqueLabel: String?

    public var suppressExpirationWhenObjectivesComplete: Bool?

    /** The enumeration matching the tier type of the item to known values, again for convenience sake. */
    public var tierType: Int?

    /** The hash identifier for the Tier Type of the item, use to look up its DestinyItemTierTypeDefinition if you need to show localized data for the item's tier. */
    public var tierTypeHash: Int?

    /** The localized name of the tier type, which is a useful shortcut so you don't have to look up the definition every time. However, it's mostly a holdover from days before we had a DestinyItemTierTypeDefinition to refer to. */
    public var tierTypeName: String?

    public init(bucketTypeHash: Int? = nil, expirationTooltip: String? = nil, expiredInActivityMessage: String? = nil, expiredInOrbitMessage: String? = nil, isInstanceItem: Bool? = nil, maxStackSize: Int? = nil, recoveryBucketTypeHash: Int? = nil, stackUniqueLabel: String? = nil, suppressExpirationWhenObjectivesComplete: Bool? = nil, tierType: Int? = nil, tierTypeHash: Int? = nil, tierTypeName: String? = nil) {
        self.bucketTypeHash = bucketTypeHash
        self.expirationTooltip = expirationTooltip
        self.expiredInActivityMessage = expiredInActivityMessage
        self.expiredInOrbitMessage = expiredInOrbitMessage
        self.isInstanceItem = isInstanceItem
        self.maxStackSize = maxStackSize
        self.recoveryBucketTypeHash = recoveryBucketTypeHash
        self.stackUniqueLabel = stackUniqueLabel
        self.suppressExpirationWhenObjectivesComplete = suppressExpirationWhenObjectivesComplete
        self.tierType = tierType
        self.tierTypeHash = tierTypeHash
        self.tierTypeName = tierTypeName
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        bucketTypeHash = try container.decodeIfPresent("bucketTypeHash")
        expirationTooltip = try container.decodeIfPresent("expirationTooltip")
        expiredInActivityMessage = try container.decodeIfPresent("expiredInActivityMessage")
        expiredInOrbitMessage = try container.decodeIfPresent("expiredInOrbitMessage")
        isInstanceItem = try container.decodeIfPresent("isInstanceItem")
        maxStackSize = try container.decodeIfPresent("maxStackSize")
        recoveryBucketTypeHash = try container.decodeIfPresent("recoveryBucketTypeHash")
        stackUniqueLabel = try container.decodeIfPresent("stackUniqueLabel")
        suppressExpirationWhenObjectivesComplete = try container.decodeIfPresent("suppressExpirationWhenObjectivesComplete")
        tierType = try container.decodeIfPresent("tierType")
        tierTypeHash = try container.decodeIfPresent("tierTypeHash")
        tierTypeName = try container.decodeIfPresent("tierTypeName")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(bucketTypeHash, forKey: "bucketTypeHash")
        try container.encodeIfPresent(expirationTooltip, forKey: "expirationTooltip")
        try container.encodeIfPresent(expiredInActivityMessage, forKey: "expiredInActivityMessage")
        try container.encodeIfPresent(expiredInOrbitMessage, forKey: "expiredInOrbitMessage")
        try container.encodeIfPresent(isInstanceItem, forKey: "isInstanceItem")
        try container.encodeIfPresent(maxStackSize, forKey: "maxStackSize")
        try container.encodeIfPresent(recoveryBucketTypeHash, forKey: "recoveryBucketTypeHash")
        try container.encodeIfPresent(stackUniqueLabel, forKey: "stackUniqueLabel")
        try container.encodeIfPresent(suppressExpirationWhenObjectivesComplete, forKey: "suppressExpirationWhenObjectivesComplete")
        try container.encodeIfPresent(tierType, forKey: "tierType")
        try container.encodeIfPresent(tierTypeHash, forKey: "tierTypeHash")
        try container.encodeIfPresent(tierTypeName, forKey: "tierTypeName")
    }

    public static func == (lhs: DestinyDefinitionsDestinyItemInventoryBlockDefinition, rhs: DestinyDefinitionsDestinyItemInventoryBlockDefinition) -> Bool {
        guard lhs.bucketTypeHash == rhs.bucketTypeHash else { return false }
        guard lhs.expirationTooltip == rhs.expirationTooltip else { return false }
        guard lhs.expiredInActivityMessage == rhs.expiredInActivityMessage else { return false }
        guard lhs.expiredInOrbitMessage == rhs.expiredInOrbitMessage else { return false }
        guard lhs.isInstanceItem == rhs.isInstanceItem else { return false }
        guard lhs.maxStackSize == rhs.maxStackSize else { return false }
        guard lhs.recoveryBucketTypeHash == rhs.recoveryBucketTypeHash else { return false }
        guard lhs.stackUniqueLabel == rhs.stackUniqueLabel else { return false }
        guard lhs.suppressExpirationWhenObjectivesComplete == rhs.suppressExpirationWhenObjectivesComplete else { return false }
        guard lhs.tierType == rhs.tierType else { return false }
        guard lhs.tierTypeHash == rhs.tierTypeHash else { return false }
        guard lhs.tierTypeName == rhs.tierTypeName else { return false }
        return true
    }
}
