//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** A subclass of DestinyItemQuantity, that provides not just the item and its quantity but also information that BNet can - at some point - use internally to provide more robust runtime information about the item's qualities.
If you want it, please ask! We're just out of time to wire it up right now. Or a clever person just may do it with our existing endpoints. */
public struct DestinyDefinitionsMilestonesDestinyMilestoneQuestRewardItem: APIModel {

    /** The hash identifier for the item in question. Use it to look up the item's DestinyInventoryItemDefinition. */
    public var itemHash: Int?

    /** If this quantity is referring to a specific instance of an item, this will have the item's instance ID. Normally, this will be null. */
    public var itemInstanceId: Int?

    /** The amount of the item needed/available depending on the context of where DestinyItemQuantity is being used. */
    public var quantity: Int?

    /** The quest reward item *may* be associated with a vendor. If so, this is that vendor. Use this hash to look up the DestinyVendorDefinition. */
    public var vendorHash: Int?

    /** The quest reward item *may* be associated with a vendor. If so, this is the index of the item being sold, which we can use at runtime to find instanced item information for the reward item. */
    public var vendorItemIndex: Int?

    public init(itemHash: Int? = nil, itemInstanceId: Int? = nil, quantity: Int? = nil, vendorHash: Int? = nil, vendorItemIndex: Int? = nil) {
        self.itemHash = itemHash
        self.itemInstanceId = itemInstanceId
        self.quantity = quantity
        self.vendorHash = vendorHash
        self.vendorItemIndex = vendorItemIndex
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        itemHash = try container.decodeIfPresent("itemHash")
        itemInstanceId = try container.decodeIfPresent("itemInstanceId")
        quantity = try container.decodeIfPresent("quantity")
        vendorHash = try container.decodeIfPresent("vendorHash")
        vendorItemIndex = try container.decodeIfPresent("vendorItemIndex")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeIfPresent(itemHash, forKey: "itemHash")
        try container.encodeIfPresent(itemInstanceId, forKey: "itemInstanceId")
        try container.encodeIfPresent(quantity, forKey: "quantity")
        try container.encodeIfPresent(vendorHash, forKey: "vendorHash")
        try container.encodeIfPresent(vendorItemIndex, forKey: "vendorItemIndex")
    }

    public static func == (lhs: DestinyDefinitionsMilestonesDestinyMilestoneQuestRewardItem, rhs: DestinyDefinitionsMilestonesDestinyMilestoneQuestRewardItem) -> Bool {
        guard lhs.itemHash == rhs.itemHash else { return false }
        guard lhs.itemInstanceId == rhs.itemInstanceId else { return false }
        guard lhs.quantity == rhs.quantity else { return false }
        guard lhs.vendorHash == rhs.vendorHash else { return false }
        guard lhs.vendorItemIndex == rhs.vendorItemIndex else { return false }
        return true
    }
}
