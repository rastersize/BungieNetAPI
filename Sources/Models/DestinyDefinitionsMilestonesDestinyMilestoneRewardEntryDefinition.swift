//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

/** The definition of a specific reward, which may be contained in a category of rewards and that has optional information about how it is obtained. */
public struct DestinyDefinitionsMilestonesDestinyMilestoneRewardEntryDefinition: APIModel {

    /** For us to bother returning this info, we should be able to return some kind of information about why these rewards are grouped together. This is ideally that information. Look at how confident I am that this will always remain true. */
    public var displayProperties: [String: Any]?

    /** The items you will get as rewards, and how much of it you'll get. */
    public var items: [DestinyDestinyItemQuantity]?

    /** If you want to follow BNet's ordering of these rewards, use this number within a given category to order the rewards. Yeah, I know. I feel dirty too. */
    public var order: Int?

    /** The identifier for this reward entry. Runtime data will refer to reward entries by this hash. Only guaranteed unique within the specific Milestone. */
    public var rewardEntryHash: Int?

    /** The string identifier, if you care about it. Only guaranteed unique within the specific Milestone. */
    public var rewardEntryIdentifier: String?

    /** If this reward is redeemed at a Vendor, this is the hash of the Vendor to go to in order to redeem the reward. Use this hash to look up the DestinyVendorDefinition. */
    public var vendorHash: Int?

    public init(displayProperties: [String: Any]? = nil, items: [DestinyDestinyItemQuantity]? = nil, order: Int? = nil, rewardEntryHash: Int? = nil, rewardEntryIdentifier: String? = nil, vendorHash: Int? = nil) {
        self.displayProperties = displayProperties
        self.items = items
        self.order = order
        self.rewardEntryHash = rewardEntryHash
        self.rewardEntryIdentifier = rewardEntryIdentifier
        self.vendorHash = vendorHash
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: StringCodingKey.self)

        displayProperties = try container.decodeAnyIfPresent("displayProperties")
        items = try container.decodeArrayIfPresent("items")
        order = try container.decodeIfPresent("order")
        rewardEntryHash = try container.decodeIfPresent("rewardEntryHash")
        rewardEntryIdentifier = try container.decodeIfPresent("rewardEntryIdentifier")
        vendorHash = try container.decodeIfPresent("vendorHash")
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: StringCodingKey.self)

        try container.encodeAnyIfPresent(displayProperties, forKey: "displayProperties")
        try container.encodeIfPresent(items, forKey: "items")
        try container.encodeIfPresent(order, forKey: "order")
        try container.encodeIfPresent(rewardEntryHash, forKey: "rewardEntryHash")
        try container.encodeIfPresent(rewardEntryIdentifier, forKey: "rewardEntryIdentifier")
        try container.encodeIfPresent(vendorHash, forKey: "vendorHash")
    }

    public static func == (lhs: DestinyDefinitionsMilestonesDestinyMilestoneRewardEntryDefinition, rhs: DestinyDefinitionsMilestonesDestinyMilestoneRewardEntryDefinition) -> Bool {
        guard NSDictionary(dictionary: lhs.displayProperties ?? [:]).isEqual(to: rhs.displayProperties ?? [:]) else { return false }
        guard lhs.items == rhs.items else { return false }
        guard lhs.order == rhs.order else { return false }
        guard lhs.rewardEntryHash == rhs.rewardEntryHash else { return false }
        guard lhs.rewardEntryIdentifier == rhs.rewardEntryIdentifier else { return false }
        guard lhs.vendorHash == rhs.vendorHash else { return false }
        return true
    }
}
